<!DOCTYPE html>
<html lang="ko">
  <head>
    <meta charset="UTF-8" />
    <title>서울시 자전거 실시간</title>
    <style>
      body {
        font-family: sans-serif;
        padding: 2rem;
      }
      select,
      button {
        font-size: 1rem;
        padding: 0.5rem;
      }
      #bikeInfo {
        margin-top: 1rem;
        padding: 1rem;
        border-radius: 8px;
        background-color: #f7f7f7;
      }
      .grade {
        font-weight: bold;
        padding: 0.3rem 0.6rem;
        border-radius: 4px;
        display: inline-block;
      }
      .매우좋음 {
        background: #1abc9c;
        color: white;
      }
      .좋음 {
        background: #2ecc71;
        color: white;
      }
      .보통 {
        background: #f1c40f;
        color: black;
      }
      .나쁨 {
        background: #e67e22;
        color: white;
      }
      .매우나쁨 {
        background: #e74c3c;
        color: white;
      }
      #map {
        width: 100%;
        height: 400px;
        margin-top: 2rem;
        border: 1px solid #ccc;
      }
    </style>

    <!--
        <script>: 순서가 중요. html과 함께 순서대로 처리
        <script defer>: DOM 요소 접근 오류 방지. 로딩 최적화. HTML이 모두 실행된 후 처리
    -->

    <script
      defer
      type="text/javascript"
      src="//dapi.kakao.com/v2/maps/sdk.js?appkey=965ddbe772fb22f84e5dcb26a31a4e25&autoload=false&libraries=services,clusterer,drawing"
    ></script>
  </head>
  <body>
    <h2>서울시 자전거 실시간</h2>

    <div id="bikeInfo">데이터를 불러오는 중입니다...</div>
    <div id="map"></div>

    <script>
      let map;
      let markers = [];
      let infowindow;
      let clusterer = null;
      const CLUSTER_THRESHOLD_LEVEL = 8; // if map level >= this, enable clustering (more zoomed out)

      const serviceKey = "6e6262627268756237376e5a777642"; // 기존 서비스키(필요 시 변경)

      function clearMarkers() {
        // remove markers from map or clusterer
        if (clusterer) {
          try {
            clusterer.clear();
          } catch (e) {
            // ignore
          }
        }
        markers.forEach((m) => {
          try {
            m.setMap(null);
          } catch (e) {}
        });
        markers = [];
      }

      function createSvgMarkerSrc(count) {
        // choose color
        const num = Number(count) || 0;
        let color = "#f1c40f"; // default yellow
        if (num === 0) color = "#e74c3c"; // red
        else if (num >= 5) color = "#2ecc71"; // green

        const size = 36;
        const text = String(num);
        const svg = `<?xml version='1.0' encoding='utf-8'?><svg xmlns='http://www.w3.org/2000/svg' width='${size}' height='${size}' viewBox='0 0 ${size} ${size}'>
          <circle cx='${size / 2}' cy='${size / 2}' r='${
          size / 2 - 1
        }' fill='${color}' stroke='#fff' stroke-width='2'/>
          <text x='50%' y='52%' font-family='Arial, Helvetica, sans-serif' font-size='12' fill='#000' text-anchor='middle' dominant-baseline='middle' font-weight='700'>${text}</text>
        </svg>`;
        return "data:image/svg+xml;utf8," + encodeURIComponent(svg);
      }

      function createMarker(position, data) {
        const count =
          data.parkingBikeTotCnt ??
          data.parking_bike_cnt ??
          data.parkingBikeCnt ??
          0;
        const imgSrc = createSvgMarkerSrc(count);
        const imageSize = new kakao.maps.Size(36, 36);
        const imageOption = { offset: new kakao.maps.Point(18, 18) };
        const markerImage = new kakao.maps.MarkerImage(
          imgSrc,
          imageSize,
          imageOption
        );

        const marker = new kakao.maps.Marker({ position, image: markerImage });

        kakao.maps.event.addListener(marker, "click", function () {
          const name = data.stationName || data.station || "대여소";
          const content = `
            <div style="padding:8px;min-width:200px;">
              <strong>${name}</strong><br>
              거치대: ${data.rackTotCnt ?? data.rack_tot_cnt ?? "-"}대<br>
              남은 자전거: ${
                data.parkingBikeTotCnt ?? data.parking_bike_cnt ?? "-"
              }대<br>
              거치율: ${data.shared ?? data.sharedRate ?? "-"}%
            </div>
          `;
          infowindow.setContent(content);
          infowindow.open(map, marker);
        });

        markers.push(marker);
        return marker;
      }

      function createOrUpdateClusterer() {
        const level = map.getLevel();
        const enableCluster = level >= CLUSTER_THRESHOLD_LEVEL;

        // clear existing clusterer
        if (clusterer) {
          try {
            clusterer.clear();
          } catch (e) {}
          clusterer = null;
        }

        if (enableCluster) {
          clusterer = new kakao.maps.MarkerClusterer({
            map: map,
            averageCenter: true,
            minLevel: 1,
            disableClickZoom: true,
            gridSize: 60,
          });
          // add all markers to clusterer
          if (markers.length) clusterer.addMarkers(markers);
        } else {
          // show individual markers on map
          markers.forEach((m) => m.setMap(map));
        }
      }

      function fitBoundsToMarkers() {
        if (markers.length === 0) return;
        const bounds = new kakao.maps.LatLngBounds();
        markers.forEach((m) => bounds.extend(m.getPosition()));
        map.setBounds(bounds);
      }

      async function loadData() {
        clearMarkers();
        document.getElementById("bikeInfo").innerText =
          "데이터를 불러오는 중입니다...";

        // Fetch all pages of data (page size 1000), accumulating results
        const pageSize = 1000;
        let start = 1;
        let allRows = [];
        let totalCount = null;
        const geocoder = new kakao.maps.services.Geocoder();

        try {
          while (true) {
            const end = start + pageSize - 1;
            const url = `http://openapi.seoul.go.kr:8088/${serviceKey}/json/bikeList/${start}/${end}/`;
            const res = await fetch(url);
            const data = await res.json();
            // console.log('page response', start, end, data);

            // try multiple possible root names
            const root = data.rentBikeStatus || data.bikeList || data;
            const rows = root?.row || root?.rows || [];
            if (totalCount == null) {
              totalCount = root?.list_total_count || root?.list_total || null;
            }

            if (rows && rows.length) {
              allRows = allRows.concat(rows);
            }

            document.getElementById("bikeInfo").innerText = `불러온 대여소: ${
              allRows.length
            }${totalCount ? " / 전체 " + totalCount : ""}`;

            if (!rows || rows.length < pageSize) break;
            // safety: if totalCount present and we've reached it, break
            if (totalCount && allRows.length >= totalCount) break;
            start += pageSize;
          }

          if (!allRows || allRows.length === 0) {
            document.getElementById("bikeInfo").innerText =
              "데이터가 없습니다.";
            return;
          }

          // Create markers (separate geocode-needed items)
          const needGeocode = [];

          allRows.forEach((item) => {
            const lat =
              item.stationLatitude ||
              item.RLAT ||
              item.lat ||
              item.위도 ||
              item.LAT ||
              item.latitude ||
              item.Y ||
              item.Y_VALUE;
            const lng =
              item.stationLongitude ||
              item.RLOT ||
              item.lng ||
              item.경도 ||
              item.LON ||
              item.longitude ||
              item.X ||
              item.X_VALUE;

            if (lat && lng) {
              createMarker(
                new kakao.maps.LatLng(parseFloat(lat), parseFloat(lng)),
                item
              );
            } else {
              needGeocode.push(item);
            }
          });

          // Geocode sequentially to avoid quota bursts
          for (const item of needGeocode) {
            let addr = item.stationName || item.station || "";
            addr = addr.replace(/^\d+\.?\s*/, "");
            if (addr.includes(".")) {
              const parts = addr.split(".");
              addr = parts.slice(1).join(".").trim();
            }

            await new Promise((resolve) => {
              geocoder.addressSearch(addr, function (result, status) {
                if (status === kakao.maps.services.Status.OK && result[0]) {
                  const coords = new kakao.maps.LatLng(
                    result[0].y,
                    result[0].x
                  );
                  createMarker(coords, item);
                } else {
                  console.warn("지오코딩 실패(주소):", addr);
                }
                // small delay to be gentle on geocode service
                setTimeout(resolve, 120);
              });
            });
          }

          document.getElementById(
            "bikeInfo"
          ).innerText = `총 ${allRows.length}개 대여소를 표시합니다.`;

          // Apply clusterer or show markers depending on zoom
          createOrUpdateClusterer();
          fitBoundsToMarkers();
        } catch (err) {
          console.error("fetch 실패 또는 파싱 오류:", err);
          document.getElementById("bikeInfo").innerText =
            "데이터 불러오기 실패";
        }
      }

      window.onload = function () {
        kakao.maps.load(function () {
          map = new kakao.maps.Map(document.getElementById("map"), {
            center: new kakao.maps.LatLng(37.5665, 126.978),
            level: 9,
          });
          infowindow = new kakao.maps.InfoWindow({ removable: true });
          // Try to center on user's location
          if (navigator.geolocation) {
            navigator.geolocation.getCurrentPosition(
              (pos) => {
                const lat = pos.coords.latitude;
                const lng = pos.coords.longitude;
                map.setCenter(new kakao.maps.LatLng(lat, lng));
                map.setLevel(7);
                // add a small dot marker for current position
                new kakao.maps.Marker({
                  map: map,
                  position: new kakao.maps.LatLng(lat, lng),
                  title: "현재 위치",
                });
              },
              (err) => {
                console.warn("geolocation failed", err);
              },
              { enableHighAccuracy: true, timeout: 5000 }
            );
          }

          // listen zoom changes to toggle clustering
          kakao.maps.event.addListener(map, "zoom_changed", function () {
            // update clusterer according to new level
            try {
              createOrUpdateClusterer();
            } catch (e) {
              console.error(e);
            }
          });

          loadData();
        });
      };
    </script>
  </body>
</html>
